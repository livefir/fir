package e2e

import (
	"context"
	"net/http"
	"net/http/httptest"
	"strings"
	"sync/atomic"
	"testing"
	"time"

	"github.com/chromedp/chromedp"
	"github.com/livefir/fir"
)

// CounterRoute defines the handlers and template for the counter example.
// This is a simplified version of your main.go's index() for testability.
func counterRouteForTest() fir.RouteOptions {
	var count int32 // Each test server instance will have its own count
	return fir.RouteOptions{
		fir.ID("counter"),
		// In a real E2E setup for a larger app, you might serve actual files.
		// For this self-contained example, embedding the HTML is fine,
		// or ensure count.html is accessible relative to where the test runs.
		// For simplicity, let's assume count.html is in a known relative path
		// or use fir.Content if it's simpler for the test setup.
		// If examples/counter/count.html is the correct path from the project root:
		fir.Content("../counter/count.html"), // Adjust path as needed
		fir.OnLoad(func(ctx fir.RouteContext) error {
			return ctx.KV("count", atomic.LoadInt32(&count))
		}),
		fir.OnEvent("inc", func(ctx fir.RouteContext) error {
			atomic.AddInt32(&count, 1)
			return ctx.KV("count", atomic.LoadInt32(&count))
		}),
		fir.OnEvent("dec", func(ctx fir.RouteContext) error {
			atomic.AddInt32(&count, -1)
			// Optional: Add logic to prevent going below zero if desired
			// if atomic.LoadInt32(&count) < 0 {
			// 	atomic.StoreInt32(&count, 0)
			// }
			return ctx.KV("count", atomic.LoadInt32(&count))
		}),
	}
}

func TestCounterExampleE2E(t *testing.T) {
	controller := fir.NewController("counter_example_e2e_"+strings.ReplaceAll(t.Name(), "/", "_"), fir.DevelopmentMode(true))
	// Create a new http.ServeMux for each test to avoid conflicts if running tests in parallel
	mux := http.NewServeMux()
	mux.Handle("/", controller.RouteFunc(func() fir.RouteOptions { return counterRouteForTest() }))
	ts := httptest.NewServer(mux)
	defer ts.Close()

	opts := append(chromedp.DefaultExecAllocatorOptions[:],
		chromedp.NoFirstRun,
		chromedp.NoDefaultBrowserCheck,
	)

	allocCtx, cancelAlloc := chromedp.NewExecAllocator(context.Background(), opts...)
	defer cancelAlloc()

	ctx, cancel := chromedp.NewContext(allocCtx, chromedp.WithLogf(t.Logf))
	defer cancel()
	// Optional: Slow down operations to observe
	// ctx = CtxWithSlowMo(ctx, 2*time.Second)

	timeoutCtx, cancelTimeout := context.WithTimeout(ctx, 30*time.Second) // Increase timeout for debugging
	defer cancelTimeout()

	var initialCountText, countAfterIncText, countAfterDecText string

	// Selectors based on count.html
	// This XPath selector is designed to find the div based on its text content,
	// the presence of attributes generated by Fir for the "inc" and "dec" events,
	// AND the presence of generated class names.
	countDisplaySelector := `//div[
								starts-with(normalize-space(.), 'Count:') and 
								count(@*[starts-with(name(), '@fir:inc:ok::fir-')]) > 0 and 
								count(@*[starts-with(name(), '@fir:dec:ok::fir-')]) > 0 and
								contains(@class, 'fir-inc-ok--fir-') and
								contains(@class, 'fir-dec-ok--fir-')
							]`
	incrementButtonSelector := `//button[@formaction="/?event=inc"]`
	decrementButtonSelector := `//button[@formaction="/?event=dec"]`

	err := chromedp.Run(timeoutCtx,
		chromedp.Navigate(ts.URL),
		chromedp.WaitVisible(countDisplaySelector, chromedp.BySearch), // Use BySearch for XPath
		chromedp.TextContent(countDisplaySelector, &initialCountText, chromedp.BySearch),

		chromedp.Click(incrementButtonSelector, chromedp.BySearch),
		// Wait for the DOM to update. A small sleep is often necessary.
		// For more robust tests, wait for specific text or attribute change.
		chromedp.Sleep(300*time.Millisecond), // Consider increasing if updates are slow
		chromedp.TextContent(countDisplaySelector, &countAfterIncText, chromedp.BySearch),

		chromedp.Click(decrementButtonSelector, chromedp.BySearch),
		chromedp.Sleep(300*time.Millisecond), // Consider increasing if updates are slow
		chromedp.TextContent(countDisplaySelector, &countAfterDecText, chromedp.BySearch),
	)

	if err != nil {
		t.Fatalf("Chromedp execution failed: %v", err)
	}

	// Helper to extract the number from "Count:X"
	extractCount := func(text string) string {
		parts := strings.Split(text, ":")
		if len(parts) == 2 {
			return strings.TrimSpace(parts[1])
		}
		return "N/A" // Or handle error
	}

	if initial := extractCount(initialCountText); initial != "0" {
		t.Errorf("expected initial count to be 0, got %s (full text: %q)", initial, initialCountText)
	}
	if afterInc := extractCount(countAfterIncText); afterInc != "1" {
		t.Errorf("expected count after increment to be 1, got %s (full text: %q)", afterInc, countAfterIncText)
	}
	if afterDec := extractCount(countAfterDecText); afterDec != "0" {
		t.Errorf("expected count after decrement to be 0, got %s (full text: %q)", afterDec, countAfterDecText)
	}
}
