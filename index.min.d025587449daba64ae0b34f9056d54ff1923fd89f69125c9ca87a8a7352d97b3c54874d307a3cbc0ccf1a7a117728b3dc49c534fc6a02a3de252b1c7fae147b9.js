var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/overview/",title:"Overview",description:"Overview docs.",content:""}),e.add({id:1,href:"/docs/tutorials/quick-start/",title:"Quick Start",description:"A quick start for the Fir toolkit",content:"Lets spend the next 15 minutes creating a simple app. If you want to skip ahead and look at final code, its here: examples/tasks/main.go\nPrerequisites # Have you installed Go 1.18 ? If yes, we are good to go.\nCreating a new app # The fir library concerns itself with only the view controller so starting off is as easy as mounting a view on the fir controller:\npackage main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) func main() { controller := fir.NewController(\u0026quot;task_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;fir.DefaultView{})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } mkdir hello-fir \u0026amp;\u0026amp; cd hello-fir touch main.go # copy-paste the above snippet go get ./... go run main.go Open localhost:9867 to see the running app.\nWe have created a controller and registered a DefaultView by calling controller.Handler(\u0026amp;fir.HelloView{}). The contoller.Handler method accepts a View interface. fir.DefaultView satisfies the methods for the View interface with default values.\nThe fir library doesn\u0026rsquo;t manage routing so you can bring your favorite routing library to actually route requests to the view. Here we keep it simple and mount the http.HandlerFunc returned by controller.Handler on the / route: http.Handle(\u0026quot;/\u0026quot;, c.Handler(\u0026amp;fir.DefaultView{}))\nCreating a new view # Lets start rendering a simple html page. To do this we want to create a new view and replace DefaultView.\nThis is how we do that:\ntype TaskView struct { fir.DefaultView } func (*TaskView) Content() string { return \u0026quot;A tasks app\u0026quot; } In the above snippet we have created a new struct, TaskView and embedded a fir.DefaultView type in it to satisfy the View interface.\npackage main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Task struct { Text string `json:\u0026quot;text\u0026quot; schema:\u0026quot;text\u0026quot;` } type TaskView struct { fir.DefaultView tasks []Task sync.RWMutex } func (*TaskView) Content() string { return \u0026quot;A tasks app\u0026quot; } func main() { controller := fir.NewController(\u0026quot;task_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;TaskView{tasks: make([]Task, 0)})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } Run the above code to see the changes at localhost:9867.\nRender Page # A Page in fir is a full web page which is rendered when a route is loaded. The View interface exposes two methods to render pages: OnGet and OnPost. OnGet is called when the page is loaded with a http GET request. We override OnGet to supply data to html/template renderer. OnPost can be overriden to handle form submissions from the browser. Both of these methods reload and re-render the full page.\npackage main import ( \u0026quot;net/http\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Task struct { Text string `json:\u0026quot;text\u0026quot; schema:\u0026quot;text\u0026quot;` } type TaskView struct { fir.DefaultView tasks []Task sync.RWMutex } func (t *TaskView) OnGet(_ http.ResponseWriter, _ *http.Request) fir.Page { t.RLock() defer t.RUnlock() return fir.Page{Data: map[string]any{\u0026quot;tasks\u0026quot;: t.tasks}} } func (t *TaskView) OnPost(_ http.ResponseWriter, r *http.Request) fir.Page { t.Lock() defer t.Unlock() var task Task if err := fir.DecodeForm(\u0026amp;task, r); err != nil { return fir.PageError(err, \u0026quot;failed to decode form\u0026quot;) } t.tasks = append(t.tasks, task) return fir.Page{Data: map[string]any{\u0026quot;tasks\u0026quot;: t.tasks}} } func (*TaskView) Content() string { return ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Tasks\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026quot;new-task\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;text\u0026quot; placeholder=\u0026quot;New task\u0026quot; /\u0026gt; \u0026lt;/form\u0026gt; {{range .tasks}} \u0026lt;div\u0026gt;{{.Text}}\u0026lt;/div\u0026gt; {{end}} \u0026lt;/div\u0026gt;` } func main() { controller := fir.NewController(\u0026quot;task_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;TaskView{tasks: make([]Task, 0)})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } Run the above update code. Go to localhost submit a new task.\nCreating a new task is handled by OnPost which appends a new task to tasks and then re-renders the Page with updated tasks.\nPatch Page # In the above example, we reload the entire page when a new task is created. Fir offers a way to re-render sections of a page without reloading the page. We call this a Patch operation. If we look at the html being rendered, we can see that only following snippet needs to be re-rendered instead of the whole page:\n{{range .tasks}} \u0026lt;div\u0026gt;{{.Text}}\u0026lt;/div\u0026gt; {{end}} Since we want to re-render this section of our html on the server, we will wrap it around in a defined template(html/template). We will use the block action.\nThe updated html snippet should look like this:\n{{block \u0026quot;tasks\u0026quot; .}} \u0026lt;div id=\u0026quot;tasks\u0026quot;\u0026gt; {{range .tasks}} \u0026lt;div\u0026gt;{{.Text}}\u0026lt;/div\u0026gt; {{end}} \u0026lt;/div\u0026gt; {{end}} The range action is wrapped in a \u0026lt;div id=\u0026quot;tasks\u0026quot;\u0026gt; so that we can target that html section for re-rendering it. We now need a way to handle the form submission and respond with a Patch operation to update the changed section.\nEmit page events # Fir has a companion javascript library which lets you send browser events to the server. You can use these events to change server state(in our case: tasks []Task) and make partial page updates without a page reload. Lets include the fir javascript library in our html page by overriding the Layout method of the View interface. We have also updated the Content() method:\nA defined template named content({{define \u0026quot;content\u0026quot;}} ... {{end}}{%end%}) which can be replaced in the Layout html string. \u0026lt;div x-data\u0026gt; so that we can use alpinejs features within this div tag. func (*TaskView) Layout() string { return ` \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{.app_name}}\u0026lt;/title\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/@adnaanx/fir@latest/dist/fir.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{template \u0026quot;content\u0026quot; .}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;` } func (*TaskView) Content() string { return ` {{define \u0026quot;content\u0026quot;}} \u0026lt;div x-data\u0026gt; \u0026lt;h1\u0026gt;Tasks\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026quot;new-task\u0026quot; method=\u0026quot;post\u0026quot; @submit.prevent=\u0026quot;$fir.emit()\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;text\u0026quot; placeholder=\u0026quot;New task\u0026quot; /\u0026gt; \u0026lt;/form\u0026gt; {{block \u0026quot;tasks\u0026quot; .}} \u0026lt;div id=\u0026quot;tasks\u0026quot;\u0026gt; {{range .tasks}} \u0026lt;div\u0026gt;{{.Text}}\u0026lt;/div\u0026gt; {{end}} \u0026lt;/div\u0026gt; {{end}} \u0026lt;/div\u0026gt; {{end}}` } Now we can use alpinejs @submit.prevent binding to call a utility function from the library: $fir.emit().\n\u0026lt;form id=\u0026quot;new-task\u0026quot; method=\u0026quot;post\u0026quot; @submit.prevent=\u0026quot;$fir.emit()\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;text\u0026quot; placeholder=\u0026quot;New task\u0026quot; /\u0026gt; \u0026lt;/form\u0026gt; In the above snippet, we use the custom Alpinejs magic function, $fir.emit() to send an event to the server on form submission. Internally $fir.emit() collects the form data and sends a post request to the controller. Shortly we will see how to handle this event to change state on the server, followed by updating tasks on the web page.\nHandle page events # To handle page events emitted by the fir client library, we override the OnEvent method of the View interface. In response to a page event, we want to send back a set of Patch operations which can modify targeted sections of the page.\n... func (t *TaskView) OnEvent(event fir.Event) fir.Patchset { switch event.ID { case \u0026quot;new-task\u0026quot;: var task Task if err := event.DecodeFormParams(\u0026amp;task); err != nil { return fir.PatchError(err, \u0026quot;failed to decode task\u0026quot;) } t.Lock() defer t.Unlock() t.tasks = append(t.tasks, task) return fir.Patchset{ fir.Replace{ Selector: \u0026quot;#tasks\u0026quot;, HTML: \u0026amp;fir.Render{ Template: \u0026quot;tasks\u0026quot;, Data: map[string]any{\u0026quot;tasks\u0026quot;: t.tasks}, }, }, } } return nil } Final # The big idea behind Fir is wrapping a div in a {{ template ...}} html/template action and then later patching it over standard HTTP on state change. Below is the final code:\npackage main import ( \u0026quot;net/http\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Task struct { Text string `json:\u0026quot;text\u0026quot; schema:\u0026quot;text\u0026quot;` } type TaskView struct { fir.DefaultView tasks []Task sync.RWMutex } func (t *TaskView) OnGet(_ http.ResponseWriter, _ *http.Request) fir.Page { t.RLock() defer t.RUnlock() return fir.Page{Data: map[string]any{\u0026quot;tasks\u0026quot;: t.tasks}} } func (t *TaskView) OnPost(_ http.ResponseWriter, r *http.Request) fir.Page { t.Lock() defer t.Unlock() var task Task if err := fir.DecodeForm(\u0026amp;task, r); err != nil { return fir.PageError(err, \u0026quot;failed to decode form\u0026quot;) } t.tasks = append(t.tasks, task) return fir.Page{Data: map[string]any{\u0026quot;tasks\u0026quot;: t.tasks}} } func (t *TaskView) OnEvent(event fir.Event) fir.Patchset { switch event.ID { case \u0026quot;new-task\u0026quot;: var task Task if err := event.DecodeFormParams(\u0026amp;task); err != nil { return fir.PatchError(err, \u0026quot;failed to decode task\u0026quot;) } t.Lock() defer t.Unlock() t.tasks = append(t.tasks, task) return fir.Patchset{ fir.Replace{ Selector: \u0026quot;#tasks\u0026quot;, HTML: \u0026amp;fir.Render{ Template: \u0026quot;tasks\u0026quot;, Data: map[string]any{\u0026quot;tasks\u0026quot;: t.tasks}, }, }, } } return nil } func (*TaskView) Layout() string { return ` \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{.app_name}}\u0026lt;/title\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/@adnaanx/fir@latest/dist/fir.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{template \u0026quot;content\u0026quot; .}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;` } func (*TaskView) Content() string { return ` {{define \u0026quot;content\u0026quot;}} \u0026lt;div x-data\u0026gt; \u0026lt;h1\u0026gt;Tasks\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026quot;new-task\u0026quot; method=\u0026quot;post\u0026quot; @submit.prevent=\u0026quot;$fir.emit()\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;text\u0026quot; placeholder=\u0026quot;New task\u0026quot; /\u0026gt; \u0026lt;/form\u0026gt; {{block \u0026quot;tasks\u0026quot; .}} \u0026lt;div id=\u0026quot;tasks\u0026quot;\u0026gt; {{range .tasks}} \u0026lt;div\u0026gt;{{.Text}}\u0026lt;/div\u0026gt; {{end}} \u0026lt;/div\u0026gt; {{end}} \u0026lt;/div\u0026gt; {{end}}` } func main() { controller := fir.NewController(\u0026quot;task_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;TaskView{tasks: make([]Task, 0)})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } "}),e.add({id:2,href:"/docs/tutorials/",title:"Tutorials",description:"Tutorial docs.",content:""}),e.add({id:3,href:"/docs/api/",title:"API",description:"API reference.",content:""}),e.add({id:4,href:"/docs/api/go/",title:"Go",description:"pkg.go.dev/github.com/adnaan/fir",content:`pkg.go.dev/github.com/adnaan/fir
`}),e.add({id:5,href:"/docs/overview/introduction/",title:"Introduction",description:"Fir is a toolkit to build server-rendered HTML apps and progressively enhance them to enable real-time user experiences. The toolkit is meant for developers who want to build real-time web apps using Go, server-rendered HTML(html/template), CSS and sprinkles of declarative javascript(alpine.js). It can be used to build: static websites like a landing page or a blog, interactive CRUD apps like ticket helpdesks, real-time apps like metrics dashboards or social media streams.",content:`Fir is a toolkit to build server-rendered HTML apps and progressively enhance them to enable real-time user experiences. The toolkit is meant for developers who want to build real-time web apps using Go, server-rendered HTML(html/template), CSS and sprinkles of declarative javascript(alpine.js). It can be used to build: static websites like a landing page or a blog, interactive CRUD apps like ticket helpdesks, real-time apps like metrics dashboards or social media streams.
The toolkit consists of a Go server library, an alpine.js plugin, and a CLI. The server library can render HTML over both HTTP and real-time connections(websockets, HTTP/2) while the alpine.js plugin provides a declarative API to enhance plain HTML to support real-time user interaction. The CLI can generate HTML views and SQL ORMs from entgo schemas(similar to Django, Rails, Phoenix frameworks).
The big idea behind Fir is to enhance Go’s standard html template engine with alpine.js to patch only parts of an HTML on user interaction and without page reloads. A Fir app can start as a simple HTML app which works without javascript depending on browser’s capability(form submissions) to handle user interactions but requires page reloads. This server-rendered HTML app can later be enhanced using sprinkles of declarative javascript provided by the companion alpine.js plugin. After the enhancement, user interactions(clicks, form submits) are sent over a real-time connection(websocket, HTTP/2) and change operations(patching the DOM, updating state, navigation etc.) are applied on the client without page reloads. The server library has the capability to publish these page change operations to all connected clients(multiple devices, multiple tabs etc.) which enables a real-time user experience. When real-time connections are not available, the client falls back to using standard HTTP while still providing user interactions without page reloads.
Consider the following html/template page:
\u0026lt;form name=\u0026quot;newTodo\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input name=\u0026quot;text\u0026quot; class=\u0026quot;input\u0026quot; type=\u0026quot;text\u0026quot; required/\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot; value=\u0026quot;Submit\u0026quot;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div id=\u0026quot;todos\u0026quot;\u0026gt; {{ range .todos }} \u0026lt;div id=\u0026quot;{{.ID}}\u0026quot;\u0026gt; {{.Text}} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/div\u0026gt; On form submission, server’s template engine hydrates the page template with updated todos and renders the new html page as http response.
To avoid a page reload and update only the changed part of the page (i.e {{range .todos}} .Text {{end}} ), we need a client javascript function which can fetch the updated part from the server and patch the relevant section of the DOM(). Also, the server’s template engine should be capable of re-rendering only the changed part of the template. A Go html template page can be composed of reusable parts enclosed in a templateor block expression. Fir builds on top of Go’s standard capability by providing a way to re-render a template/block part and patching the targeted part of the page without a page reload while using only a bit of javascript.
\u0026lt;form name=\u0026quot;newTodo\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input name=\u0026quot;text\u0026quot; class=\u0026quot;input\u0026quot; type=\u0026quot;text\u0026quot; required/\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot; value=\u0026quot;Submit\u0026quot;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div id=\u0026quot;todos\u0026quot;\u0026gt; **{{ block \u0026quot;todos\u0026quot; . }}** {{ range .todos }} \u0026lt;div id=\u0026quot;{{.ID}}\u0026quot;\u0026gt; {{.Text}} \u0026lt;/div\u0026gt; {{ end }} **{{ end }}** \u0026lt;/div\u0026gt; In the above page, range is enclosed in a block expression. The block section of the page can now be re-rendered by looking it up by name in the template tree. Fir’s alpine.js plugin can enhance this page by preventing the form submission request and sending a json event instead. On receiving the event, Fir server re-renders the todos block and sends back a html snippet. The fir alpine.js plugin replaces the content of the todos div with the returned html snippet.
\u0026lt;form **x-data @submit.prevent=\u0026quot;\$fir.emit()\u0026quot;** name=\u0026quot;newTodo\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input name=\u0026quot;text\u0026quot; class=\u0026quot;input\u0026quot; type=\u0026quot;text\u0026quot; required/\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot; value=\u0026quot;Submit\u0026quot;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div id=\u0026quot;todos\u0026quot;\u0026gt; {{ block \u0026quot;todos\u0026quot; . }} {{ range .todos }} \u0026lt;div id=\u0026quot;{{.ID}}\u0026quot;\u0026gt; {{.Text}} \u0026lt;/div\u0026gt; {{ end }} {{ end }} \u0026lt;/div\u0026gt; x-data attribute on the newTodo form declares it as a new Alpine component. @submit.prevent is a x-on directive which prevents the form submission and calls \$fir.emit() custom magic function instead. The \$fir.emit() function reads the Form element data and sends a fir.Event over a real-time connection or a regular fetch call if a real-time connection is unavailable. The event is handled on the server and a patch operation is sent back. The patch operation is then applied the DOM by the alpine.js plugin.
`}),e.add({id:6,href:"/docs/api/alpinejs-plugin/",title:"Alpine.js Plugin",description:"$fir.emit(id, params) # $fir.emit is a magic function that returns an event handler(function(event){...}) that emits an event with the given id and params to the current fir route handler.\nid must be a string and is required. If not passed as an argument, id is picked from the DOM in the following order:\nelement.id form.action=\u0026quot;/?event=myevent\u0026quot; button.formaction=\u0026quot;/?event=myevent\u0026quot; Usage:\n\u0026lt;button @click=\u0026quot;$fir.emit('inc')\u0026quot;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026quot;dec\u0026quot;@click=\u0026quot;$fir.emit()\u0026quot;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;form id=\u0026quot;createTodo\u0026quot; method=\u0026quot;post\u0026quot; @submit.prevent=\u0026quot;$fir.emit()\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;todo\u0026quot; placeholder=\u0026quot;a new todo\u0026quot; /\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; params can be of any type and is optional.",content:`\`fir.emit(id, params) # \`fir.emit is a magic function that returns an event handler(function(event){...}) that emits an event with the given id and params to the current fir route handler.
id must be a string and is required. If not passed as an argument, id is picked from the DOM in the following order:
element.id form.action=\u0026quot;/?event=myevent\u0026quot; button.formaction=\u0026quot;/?event=myevent\u0026quot; Usage:
\u0026lt;button @click=\u0026quot;\$fir.emit('inc')\u0026quot;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026quot;dec\u0026quot;@click=\u0026quot;\$fir.emit()\u0026quot;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;form id=\u0026quot;createTodo\u0026quot; method=\u0026quot;post\u0026quot; @submit.prevent=\u0026quot;\$fir.emit()\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;todo\u0026quot; placeholder=\u0026quot;a new todo\u0026quot; /\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; params can be of any type and is optional. If not passed as an argument:
params composed as an object with event.target.name as key and event.target.value as value. params is composed from FormData of the form element if event.target is a form element. Events # Browser events are dispatched on start and end of \$fir.emit(...) call.
Usage:
\u0026lt;div x-data=\u0026quot;{loading: false}\u0026quot; @fir:emit-start:myevent.window=\u0026quot;loading = true\u0026quot; @fir:emit-end:myevent.window=\u0026quot;loading = false\u0026quot;\u0026gt; \u0026lt;button x-on:click=\u0026quot;\$fir.emit('myevent')\u0026quot;\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;div x-show=\u0026quot;loading\u0026quot;\u0026gt;Loading...\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; fir:emit # Emitted when \$fir.emit(...) call is started and finished. It can be used to toggle a loading indicator.
Usage:
\u0026lt;div x-data=\u0026quot;{loading: false}\u0026quot; @ir:emit:myevent.window=\u0026quot;loading = !loading\u0026quot;\u0026gt; \u0026lt;button x-on:click=\u0026quot;\$fir.emit('myevent')\u0026quot;\u0026gt;Click me\u0026lt;/button\u0026gt; \u0026lt;div x-show=\u0026quot;loading\u0026quot;\u0026gt;Loading...\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; fir:emit-start # Emitted when \$fir.emit(...) call is started.
Usage:
\u0026lt;div @fir:emit-start:myevent.window=\u0026quot;loading = true\u0026quot; \u0026gt;\u0026lt;/div\u0026gt; fir:emit-end # Emitted when \$fir.emit(...) call is finished.
Usage:
\u0026lt;div @fir:emit-end:myevent.window=\u0026quot;loading = false\u0026quot; \u0026gt;\u0026lt;/div\u0026gt; `}),e.add({id:7,href:"/docs/tutorials/counter-app/",title:"Counter App",description:`Lets spend the next 15 minutes creating a new reactive counter app. If you want to skip ahead and look at final code, its here: examples/counter/main.go
Prerequisites # Have you installed Go ? If yes, we are good to go.
Creating a new app # The fir library concerns itself with only the view controller so starting off is as easy as mounting a view on the fir controller:
package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.`,content:`Lets spend the next 15 minutes creating a new reactive counter app. If you want to skip ahead and look at final code, its here: examples/counter/main.go
Prerequisites # Have you installed Go ? If yes, we are good to go.
Creating a new app # The fir library concerns itself with only the view controller so starting off is as easy as mounting a view on the fir controller:
package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) func main() { controller := fir.NewController(\u0026quot;counter_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;fir.DefaultView{})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } Copy the above snippet in a main.go file and run go run main.go. Open localhost:9867 to see the running app.
We have created a controller and registered a DefaultView by calling controller.Handler(\u0026amp;fir.HelloView{}). The contoller.Handler method accepts a View interface. fir.DefaultView satisfies the methods for the View interface with default values.
The fir library doesn\u0026rsquo;t manage routing so you can bring your favorite routing library to actually route requests to the view. Here we keep it simple and mount the http.HandlerFunc returned by controller.Handler on the / route: http.Handle(\u0026quot;/\u0026quot;, c.Handler(\u0026amp;fir.DefaultView{}))
Creating a new view # We want to build a counter app. To do this we want to create a new view and replace DefaultView.
This is how we do that:
type CounterView struct { fir.DefaultView count int32 } func (c *CounterView) Content() string { return \u0026quot;A counter app\u0026quot; } In the above snippet we have created a new struct, CounterView and embedded a fir.DefaultView type in it to satisfy the View interface.
package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Counter struct { count int32 } type CounterView struct { fir.DefaultView model *Counter } func (c *CounterView) Content() string { return \u0026quot;A counter app\u0026quot; } func main() { controller := fir.NewController(\u0026quot;counter_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;CounterView{model: \u0026amp;Counter{}})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } Run the above code to see the changes at localhost:9867.
User interaction # Fir has a companion javascript library which lets you send browser events to the server. You can use these events to change server state(in our case: model *Counter) and make partial page updates without a page reload.
\u0026lt;div\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('inc')\u0026quot;\u0026gt;+ \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('dec')\u0026quot;\u0026gt;- \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; In the above snippet, we use the custom Alpinejs magic function, \$fir.emit to send an event to the server on a button click. Shortly we will see how to handle this event to change state on the server, followed by updating a count on the web page.
Render view # Before we go ahead, lets expand the above snippet to a full html page.
Expand html page \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{.app_name}}\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;A counter app\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\u0026quot; /\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/@adnaanx/fir@latest/dist/fir.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;my-6\u0026quot; style=\u0026quot;height: 500px\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;columns is-mobile is-centered is-vcentered\u0026quot;\u0026gt; \u0026lt;div x-data class=\u0026quot;column is-one-third-desktop has-text-centered is-narrow\u0026quot;\u0026gt; \u0026lt;div\u0026gt; {{block \u0026quot;count\u0026quot; .}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('inc')\u0026quot;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('dec')\u0026quot;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; The html page includes the fir JS library which helps you add tiny bits of interactivity to the page. The library is an Alpinejs plugin and ships with extra direcitives(x-* thingy) and magic functions(\$ thingy).
Let\u0026rsquo;s add the above html page to the Content method of our view. The Content method can return either a valid filename or html.
Expand main.go package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Counter struct { count int32 } type CounterView struct { fir.DefaultView } func (c *CounterView) Content() string { return \`\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{.app_name}}\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;A counter app\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\u0026quot; /\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/@adnaanx/fir@latest/dist/fir.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;my-6\u0026quot; style=\u0026quot;height: 500px\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;columns is-mobile is-centered is-vcentered\u0026quot;\u0026gt; \u0026lt;div x-data class=\u0026quot;column is-one-third-desktop has-text-centered is-narrow\u0026quot;\u0026gt; \u0026lt;div\u0026gt; {{block \u0026quot;count\u0026quot; .}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('inc')\u0026quot;\u0026gt;+ \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('dec')\u0026quot;\u0026gt;- \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\` } func main() { controller := fir.NewController(\u0026quot;counter_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;CounterView{model: \u0026amp;Counter{}})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } Running the above code, show render two buttons but nothing else. We want to show an initial count on the page. To do this, we use Go\u0026rsquo;s html/template to hydrate some data into our page by overriding the OnGet method of the View interface.
func (c *CounterView) OnGet(_ http.ResponseWriter, _ *http.Request) (fir.Page) { return fir.Status{Code: 200}, map[string]any{ \u0026quot;count\u0026quot;: c.Value(), } } By default, map[string]any was zero value. After overriding OnGet we are initialising it with a count value. The page is then passed through html/template and rendered. This is the standard way of rendering html templates in Go so this should be recongisable.
{{block \u0026quot;count\u0026quot; .}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} block is a html/template built-in shorthand for defining and using a template.
This :
{{block \u0026quot;count\u0026quot; .}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} is same as:
{{define \u0026quot;count\u0026quot;}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} {{ template \u0026quot;count\u0026quot;}} Update parts of the view # In response to user interaction we want to update a part of our web page to display a result. Fir allows you to patch targeteted areas of the DOM without a page reload. Lets see it in action.
\u0026lt;div\u0026gt; {{block \u0026quot;count\u0026quot; .}} \u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt; {{end}} \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('inc')\u0026quot;\u0026gt; + \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('dec')\u0026quot;\u0026gt; - \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; When the + button is clicked, an event inc is sent to the server which sends backs a patch instruction back to the page.
func replaceCount(c int32) fir.Patch { return fir.Replace{ Selector: \u0026quot;#count\u0026quot;, HTML: \u0026amp;fir.Render{ Template: \u0026quot;count\u0026quot;, Data: map[string]any{\u0026quot;count\u0026quot;: c}, }, } } func (c *Counter) Inc() fir.Patch { return replaceCount(atomic.AddInt32(\u0026amp;c.count, 1)) } func (c *Counter) Dec() fir.Patch { return replaceCount(atomic.AddInt32(\u0026amp;c.count, -1)) } ... func (c *CounterView) OnEvent(event fir.Event) fir.Patchset { switch event.ID { case \u0026quot;inc\u0026quot;: return fir.Patchset{c.model.Inc()} case \u0026quot;dec\u0026quot;: return fir.Patchset{c.model.Dec()} default: glog.Errorf(\u0026quot;warning:handler not found for event =\u0026gt; \\n %+v\\n\u0026quot;, event) } return nil } fir.Replace is a patch which hydrates the new count value to the template count(i.e. {{block \u0026quot;count\u0026quot; .}}{%endraw%}) on the server and instructs the javascript client library to update(replace) the \u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;.
The updated main.go should now be fully working counter example.
Expand main.go package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;sync/atomic\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Counter struct { count int32 } func replaceCount(c int32) fir.Patch { return fir.Replace{ Selector: \u0026quot;#count\u0026quot;, HTML: \u0026amp;fir.Render{ Template: \u0026quot;count\u0026quot;, Data: map[string]any{\u0026quot;count\u0026quot;: c}, }, } } func (c *Counter) Inc() fir.Patch { return replaceCount(atomic.AddInt32(\u0026amp;c.count, 1)) } func (c *Counter) Dec() fir.Patch { return replaceCount(atomic.AddInt32(\u0026amp;c.count, -1)) } func (c *Counter) Value() int32 { return atomic.LoadInt32(\u0026amp;c.count) } type CounterView struct { fir.DefaultView model *Counter } func (c *CounterView) OnGet(_ http.ResponseWriter, _ *http.Request) fir.Page { return fir.Page{ Data: map[string]any{ \u0026quot;count\u0026quot;: c.model.Value(), }} } func (c *CounterView) OnEvent(event fir.Event) fir.Patchset { switch event.ID { case \u0026quot;inc\u0026quot;: return fir.Patchset{c.model.Inc()} case \u0026quot;dec\u0026quot;: return fir.Patchset{c.model.Dec()} default: glog.Errorf(\u0026quot;warning:handler not found for event =\u0026gt; \\n %+v\\n\u0026quot;, event) } return nil } func (c *CounterView) Content() string { return \`\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{.app_name}}\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;A counter app\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\u0026quot; /\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/@adnaanx/fir@latest/dist/fir.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;my-6\u0026quot; style=\u0026quot;height: 500px\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;columns is-mobile is-centered is-vcentered\u0026quot;\u0026gt; \u0026lt;div x-data class=\u0026quot;column is-one-third-desktop has-text-centered is-narrow\u0026quot;\u0026gt; \u0026lt;div\u0026gt; {{block \u0026quot;count\u0026quot; .}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('inc')\u0026quot;\u0026gt;+ \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('dec')\u0026quot;\u0026gt;- \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\` } func main() { controller := fir.NewController(\u0026quot;counter_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;CounterView{model: \u0026amp;Counter{}})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } If you want to skip ahead and look at final code for the optionals, its here: examples/counter-ticker/main.go
Optional: Layouts # Right now are, our html page is one big blob. We might want to separate out the layout from the content for reusability. To do this we need to override the Layout method of the View interface.
type LayoutView struct { fir.DefaultView } func (l *LayoutView) Content() string { return \`{{define \u0026quot;content\u0026quot;}}\u0026lt;div\u0026gt;world\u0026lt;/div\u0026gt;{{ end }}\` } func (l *LayoutView) Layout() string { return \`\u0026lt;div\u0026gt;Hello: {{template \u0026quot;content\u0026quot; .}}\u0026lt;/div\u0026gt;\` } Notice the {{template \u0026quot;content\u0026quot; .}}. Fir looks for an equivalent defined template in Content which here is: {{define \u0026quot;content\u0026quot;}}\u0026lt;div\u0026gt;world\u0026lt;/div\u0026gt;{{ end }}. By default it looks for a template named content but this can be overriden by returned a different layout name in LayoutContentName() string
Optional: Live Ticker # On user interaction events, OnEvent sends back a patchset which patches the interesting parts of the page. It would be nice to update the page when something changes for a user on the server(e.g. notifications, stock ticker, chat message etc.). Using the fir library its possible to stream a patch over websockets or server-sent events(SSE).
Override the Stream method of the View interface to return a receive only channel(\u0026lt;- chan Patch). When a patch is sent to this channel its sent to the client library where its executed to update the page.
type CounterView struct { fir.DefaultView model *Counter stream chan fir.Patch sync.RWMutex } func (c *CounterView) Stream() \u0026lt;-chan fir.Patch { return c.stream } ... http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;CounterView{stream: make(chan fir.Patch)})) We can send a patch to the stream.
c.stream \u0026lt;- fir.Replace{...} Lets expand the counter example to add a last updated ticker to the page. The ticker should update every second and tell us when was count last updated.
For this example, we use a different patch type: fir.Store{}.
func NewCounterView() *CounterView { stream := make(chan fir.Patch) ticker := time.NewTicker(time.Second) c := \u0026amp;CounterView{stream: stream, model: \u0026amp;Counter{}} go func() { for ; true; \u0026lt;-ticker.C { patch, err := c.model.Updated() if err != nil { continue } stream \u0026lt;- patch } }() return c } \u0026lt;div\u0026gt;Count updated: \u0026lt;span x-text=\u0026quot;\$store.fir.count_updated || 0\u0026quot;\u0026gt;\u0026lt;/span\u0026gt; seconds ago\u0026lt;/div\u0026gt; fir.Store{} updates the global alpinejs \$store. Since its reactive, the above html snippet automatically updates.
See the complete working example:
Expand main.go package main import ( \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Counter struct { count int32 updated time.Time sync.RWMutex } func replaceCount(c int32) fir.Patch { return fir.Replace{ Selector: \u0026quot;#count\u0026quot;, HTML: \u0026amp;fir.Render{ Template: \u0026quot;count\u0026quot;, Data: map[string]any{\u0026quot;count\u0026quot;: c}, }, } } func (c *Counter) Inc() fir.Patch { c.Lock() defer c.Unlock() c.count += 1 c.updated = time.Now() return replaceCount(c.count) } func (c *Counter) Dec() fir.Patch { c.Lock() defer c.Unlock() c.count -= 1 c.updated = time.Now() return replaceCount(c.count) } func (c *Counter) Updated() (fir.Patch, error) { c.RLock() defer c.RUnlock() if c.updated.IsZero() { return nil, fmt.Errorf(\u0026quot;time is zero\u0026quot;) } return fir.Store{ Name: \u0026quot;fir\u0026quot;, Data: map[string]any{ \u0026quot;count_updated\u0026quot;: time.Since(c.updated).Seconds(), }, }, nil } func (c *Counter) Count() int32 { c.RLock() defer c.RUnlock() return c.count } func NewCounterView() *CounterView { stream := make(chan fir.Patch) ticker := time.NewTicker(time.Second) c := \u0026amp;CounterView{stream: stream, model: \u0026amp;Counter{}} go func() { for ; true; \u0026lt;-ticker.C { patch, err := c.model.Updated() if err != nil { continue } stream \u0026lt;- patch } }() return c } type CounterView struct { fir.DefaultView model *Counter stream chan fir.Patch sync.RWMutex } func (c *CounterView) Stream() \u0026lt;-chan fir.Patch { return c.stream } func (c *CounterView) Content() string { return \` {{define \u0026quot;content\u0026quot; }} \u0026lt;div class=\u0026quot;my-6\u0026quot; style=\u0026quot;height: 500px\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;columns is-mobile is-centered is-vcentered\u0026quot;\u0026gt; \u0026lt;div x-data class=\u0026quot;column is-one-third-desktop has-text-centered is-narrow\u0026quot;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;Count updated: \u0026lt;span x-text=\u0026quot;\$store.fir.count_updated || 0\u0026quot;\u0026gt;\u0026lt;/span\u0026gt; seconds ago\u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt; {{block \u0026quot;count\u0026quot; .}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('inc')\u0026quot;\u0026gt;+ \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('dec')\u0026quot;\u0026gt;- \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{end}}\` } func (c *CounterView) Layout() string { return \`\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{.app_name}}\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;A counter app\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\u0026quot; /\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/@adnaanx/fir@latest/dist/fir.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{template \u0026quot;content\u0026quot; .}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\` } func (c *CounterView) OnGet(_ http.ResponseWriter, _ *http.Request) fir.Page { return fir.Page{ Data: map[string]any{ \u0026quot;count\u0026quot;: c.model.Count(), }} } func (c *CounterView) OnEvent(event fir.Event) fir.Patchset { switch event.ID { case \u0026quot;inc\u0026quot;: return fir.Patchset{c.model.Inc()} case \u0026quot;dec\u0026quot;: return fir.Patchset{c.model.Dec()} default: glog.Errorf(\u0026quot;warning:handler not found for event =\u0026gt; \\n %+v\\n\u0026quot;, event) } return nil } func main() { controller := fir.NewController(\u0026quot;counter_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(NewCounterView())) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } Run the above main.go and go to localhost:9867. Incrementing or decrementing the count should update the ticker.
`}),e.add({id:8,href:"/docs/overview/faq/",title:"FAQs",description:"The Fir toolkit offers a Go library, an Alpine.js plugin and a model-view generator CLI to build progressively enhanced reactive web interfaces with mostly server-rendered HTML.",content:`A Go toolkit to build reactive web interfaces.
Why does it exist ? # Wants to provide a way to build moderately complex reactive apps for folks who are comfortable with Go.
The library is a result of a series of experiments to build reactive apps in Go: gomodest-template. It works by patching the DOM on user events using replacedom.
What is it ? # Its a toolkit: a Go library, a CLI and an alpine.js plugin Focuses only on the view layer. Ships with an Alpinejs plugin for user interactions(click, submit, navigate ) etc. Who is it for ? # Suitable for Go developers who want to build moderately complex apps, internal tools, prototypes etc. Skills needed: Go, HTML, CSS, Alpine.js. What can you do with it ? # Build reactive webapps using Go, html/template and sprinkles of declarative javascript(alpine.js) Update parts of the web page on user interaction without reloading the page over regular http: clicks, form submits etc. Stream page updates over a persistent connection(WS, SSE): notifications, live tickers, chat messages etc. Use the CLI to generate html using entgo schema Is it like hotwire or is it like phoenix liveview ? # It borrows the idea of patching DOM on user interaction events from phoenix live view. But instead of streaming DOM diffs over websocket and sticthing it back on the client, it takes the hotwire approach of re-rendering html templates on the server and sending back a patch DOM operation to the javascript client over standard HTTP.
Live patching of the DOM(over websockets, sse) is also available but only for server driven DOM patching.(notifications, live ticker etc.)
Principles # Library and not a framework. It’s a Go library to build reactive user interfaces. Nothing crazy tech: It is built on nothing crazy tech: Go, html/template and Alpinejs. It’s just plain old html templates sprinkled with a bit of javascript. Keep Go code free of html/css: Use html/template to hydrate html pages. Keep Javascript to the minimum: Alpinejs provides declarative constructs to wire up moderately complex logic. The fir JS client provides additional Alpinejs functions and directives to achieve this goal. Have a simple lifecycle: Stages: Render html page -\u0026gt; Handle UI change events → Update parts of the html. Be SEO friendly: First page render is done fully on the server side. Real-time interaction is done once the page has been rendered. Have a low learning curve: For a Go user the only new thing to learn would be Alpinejs. And yes: HTML \u0026amp; CSS No custom template engine: Writing our own template engine can enable in-memory html diffing and minimal change partial for the client, but it also means maintaining a new non standard template engine. Status # Work in progress. The current focus is to get to a developer experience which is acceptable to the community. Roadmap to v1.0.0 is still uncertain.
`}),e.add({id:9,href:"/docs/",title:"Docs",description:"Docs Doks.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()