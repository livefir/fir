# Plan for Fir UI Debugging Tool

## 1. Overview

This document outlines a plan to build a UI debugging tool for the `fir` framework.

The tool will have two main components:

1. **Static Mismatch Analysis**: A startup-time tool that analyzes route templates and Go code to find discrepancies between server-sent events and client-side listeners.
2. **Live Event Inspector**: A web-based dashboard that visualizes the flow of events and UI patches in real-time.

## 2. Guiding Principles

* **Maximize Code Reuse**: The debug tool must leverage the framework's existing components for routing, template parsing, and event handling. Logic should not be duplicated in the `internal/debug` package.
* **Improve Core Logging**: Enhance the built-in logging capabilities of the framework to provide detailed diagnostics when a debug mode is enabled.
* **Non-Interference**: The debug tool must operate in a way that does not alter the application's logic, state, or core behavior. Instrumentation should be passive, and the performance overhead should be negligible, especially in production environments where the tool is disabled.
* **Zero Dependencies & Self-Contained**: The debug tool must be self-contained within the `fir` library. It will not require developers to download or manage any external JavaScript or CSS files. All necessary assets will be embedded directly into the Go binary using the standard `embed` package, which ensures they are correctly bundled even when `fir` is used as a library dependency.

## 3. Event Transport: WebSocket with HTTP Fallback

* **Primary Transport**: The framework prioritizes WebSockets for real-time, bidirectional communication.
* **HTTP Fallback**: In scenarios where a WebSocket connection cannot be established (e.g., disabled on the controller, network restrictions, or client-side errors), `fir` automatically falls back to using standard HTTP POST requests for event handling.
* **Debugging Parity**: The debugging tools must function seamlessly across both transport mechanisms. The `Live Event Inspector` will capture and display events whether they arrive via WebSocket or HTTP POST. The `Enhanced Debug Logging` will clearly indicate the transport used for each event.

## 4. Modular Event Handling Strategy

* **Introduce an Event Registry**: To decouple event definition from routing, we will introduce a central `EventRegistry` within the controller. This registry will be the single source of truth for all events in the application.
* **Event Registration**: Each `OnEvent` handler will be registered with the `EventRegistry`, associating an event ID with its handler function and the route it belongs to. This can be done during the controller's initialization phase as it processes the `fir.Route` configurations.
* **Introspection API**: The `EventRegistry` will expose a public API for introspection. The `debug/analyzer` will use this API to get a list of all registered server-side events, rather than inspecting the internal route structures of the controller. This promotes loose coupling and reusability.

## 5. Static Mismatch Analysis

This component aims to prevent runtime errors by identifying "orphaned" events—events fired by the server that have no corresponding listener in the frontend code for a given route.

### 5.1. Implementation Steps

1.  **Create an Analyzer Package**:
    * Introduce a new package, e.g., `internal/debug`.
    * This package will contain the logic for parsing and analyzing routes.

2.  **Event Source Identification**:
    * The analyzer will query the controller's `EventRegistry` to get a comprehensive list of all registered event IDs and their associated route patterns (e.g., `/users/{id}`). This replaces the need to manually inspect the `fir.Route` slice.
    * The analyzer will build a map of potential server events for each route pattern: `map[route_pattern] -> []string{event_id_1, event_id_2, ...}`.

3.  **Client Listener Extraction**:
    * For each route pattern, the analyzer will use the controller's template engine to access the parsed templates (including partials). This avoids re-implementing template discovery and parsing logic.
    * A utility function within the `debug` package will then traverse the parsed template nodes to find all attributes representing `fir` event listeners (`x-on:fir:<...>` or `@fir:<...>`).
    * The parser will extract the `event-id` from each listener.
    * The result will be a map of listeners found in the templates: `map[route_path] -> []string{listener_event_1, listener_event_2, ...}`.

4.  **Comparison and Reporting**:
    * For each route, compare the set of events generated by the server with the set of listeners found on the client.
    * An event ID from the server is considered matched if a listener for that event ID exists in the template for any of the states (`ok`, `error`, `pending`, `done`), which are documented in the [alpinejs-plugin/README.md](alpinejs-plugin/README.md).
    * Log warnings for any server event ID that does not have a corresponding client-side listener.
    * This analysis should be integrated into the server's startup sequence when in development mode.

## 6. Advanced Debugging Capabilities

To provide a truly first-class developer experience, the debug tool will draw inspiration from mature tools like the React/Vue DevTools and the Django Debug Toolbar. This means going beyond simple event logging to provide a holistic view of the application's state and structure.

*   **State Inspector**: A panel to inspect the client-side state managed by the `fir` Alpine.js plugin (`$fir.state`). This will provide a clear, real-time view of how the UI's state changes in response to server events, making it easy to debug state-related issues.
*   **Routes Inspector**: A dedicated panel to provide a complete overview of the application's structure. It will list all registered routes, their associated templates, and the event handlers they respond to, all derived from the `EventRegistry`.
*   **Performance Profiler**: The tool will offer a detailed breakdown of server-side event processing, showing time spent in the event handler versus time spent rendering each template patch. This helps developers pinpoint performance bottlenecks with precision.
*   **Integrated Error Reporting**: A new "Errors" tab will capture and display runtime errors (e.g., panics, template execution errors) with full stack traces directly in the debug UI, preventing developers from having to switch back to the console.

## 7. The Debug UI: Architecture and Features

This component provides a real-time, interactive dashboard for inspecting the `fir` system.

### 7.1. Architecture

*   **Automatic Route Handling**: The `fir` controller, when debug mode is enabled, will automatically handle requests for a predefined path (e.g., `/fir/debug`). It will inspect incoming requests in its `ServeHTTP` method and, if the path matches, it will serve the debug UI directly. This prevents the need for developers to manually register the debug route in their application's router.
*   **Instrumentation**: The controller's request handling logic will be instrumented to capture event data (request, response, metrics) and forward it to the `debug/hub`. This instrumentation is active only when debug mode is enabled.
*   **Debug Hub & Assets**: The `internal/debug` package will contain the WebSocket hub for broadcasting data to the UI and an `http.Handler` for serving the embedded assets and handling WebSocket upgrade requests. The controller will delegate to this handler for the `/fir/debug` route.

### 7.2. UI Features

The debug UI will be a single-page application with a tabbed interface:

1.  **Events Tab**:
    *   A chronological list of all captured events.
    *   Each entry will show the event ID, transport type (WebSocket/HTTP), and key performance metrics at a glance.
    *   A detailed view for a selected event, showing:
        *   **Request Context**: URL and route parameters.
        *   **Client Event**: `fir.Event` details (ID, params, etc.).
        *   **Server Response**: A list of `dom.Event` patches, with HTML rendered in a sandboxed `<iframe>` and state/data shown as formatted JSON.

2.  **State Tab**:
    *   A live view of the JSON object representing the client-side state (`$fir.state`).
    *   The view will automatically update as the state changes.

3.  **Routes Tab**:
    *   A table listing all registered application routes.
    *   For each route, it will show the associated templates and the server-side event IDs it handles.

4.  **Performance Tab**:
    *   A detailed performance breakdown for each event, visualizing the time spent in the `OnEvent` handler versus the time spent rendering each individual template patch.

5.  **Analysis Tab**:
    *   Displays the warnings generated by the Static Mismatch Analysis. This view will be updated in real-time if file watching is implemented.

6.  **Errors Tab**:
    *   A list of runtime errors captured from the server, complete with stack traces.

## 8. Reactivity and Development Workflow

To make the tool useful during development, it needs to react to code changes.

1.  **File Watching**:
    * Use a library like `fsnotify` to watch for changes in `.go` and `.html` files.
2.  **Hot Reloading**:
    * **Template Changes**: On `.html` file changes, the server can clear its template cache and re-run the static analysis. The new warnings can be pushed to the debug UI via WebSocket.
    * **Go Code Changes**: Changes to `.go` files require a re-compilation and server restart. This is best handled by an external tool like `air` or `fresh`. The debug tool should be designed to work seamlessly with such tools, leveraging the existing "Development live reload" capability mentioned in the [README.md](README.md).

## 9. Proposed File Structure

```sh
/
├── internal/
│   ├── debug/
│   │   ├── analyzer.go      # Static analysis logic (uses EventRegistry)
│   │   ├── hub.go           # WebSocket hub for the inspector
│   │   ├── capture.go       # Functions to capture event data
│   │   ├── assets.go        # Contains `//go:embed` directives and serves assets
│   │   └── assets/          # Directory for embedded HTML/JS/CSS
│   │       ├── index.html
│   │       └── app.js
│   └── event/
│       └── registry.go      # The new EventRegistry
├── controller.go            # Instrumented to call debug.Capture()
└── ...
```

## 10. Enhanced Debug Logging & Configuration
This is a parallel effort to improve the general debuggability of the core library, independent of the UI tool. It serves as the primary method for debugging when WebSockets are disabled or when a live UI is not needed.

*   **Master Debug Flag**: Introduce a new controller option, e.g., `controller.WithDebug(true)`. Enabling this option will:
    1.  Configure the global logger in `internal/logger` to output detailed, structured logs.
    2.  Enable the automatic handling of the `/fir/debug` route to serve the Debug UI.
    3.  Turn on the instrumentation required to capture and broadcast event data.
*   **Centralized, Configurable Logger**: The `internal/logger` package will be the single source of truth for all logging. It will be refactored to be configurable, supporting structured logging (e.g., using `log/slog`). All parts of the `fir` framework will use this central logger.
*   **Log Points**: Add detailed logging at critical points in the request lifecycle, with a focus on performance metrics for HTML patches:
    *   On new WebSocket connection: `INFO: websocket connected`
    *   On incoming event: `DEBUG: event received transport=[websocket|http], id=..., params=..., size=...B`
    *   Before invoking handler: `DEBUG: invoking OnEvent for id=...`
    *   On response generation: `DEBUG: sending patches count=..., target=..., size=...B, latency=...ms`
    *   On errors: `ERROR: event processing failed id=..., error=...`

## 11. Implementation Milestones

**IMPORTANT**: After completing each milestone, please stop and wait for a review before proceeding to the next one. This ensures that we can iterate on the project effectively.

### Task Progress

* [ ] **Milestone 0: Prerequisite Refactors (Internal)**
  * [x] **0.1:** Decompose the monolithic `route.ServeHTTP` method.
  * [x] **0.2:** Introduce a `Renderer` interface.
  * [x] **0.3:** Refactor WebSocket connection logic into a `Connection` struct.
  * [x] **0.4:** Ensure `fir:` attribute parsing logic is self-contained.
  * [ ] **0.5:** Replace `map[string]OnEventFunc` with `EventRegistry`.
* [ ] **Milestone 1: Foundational Logging & Configuration**
* [ ] **Milestone 2: Static Mismatch Analyzer**
* [ ] **Milestone 3: Live Capture Backend & Debug UI Scaffold**
* [ ] **Milestone 4: The "Events" Inspector Panel**
* [ ] **Milestone 5: Advanced Inspector Panels**
* [ ] **Milestone 6: Advanced Diagnostic Panels**

This section breaks down the development of the debugging tool into a series of manageable, commit-friendly milestones. Each sub-milestone is designed to be a single, atomic commit.

### Testing Requirements

**Important**: After each milestone, ensure comprehensive testing by running:

* `go test ./...` - Standard test suite
* `DOCKER=1 go test ./...` - Full test suite including Docker-dependent tests (Redis pubsub, etc.)

The Docker-enabled tests provide additional coverage for features like Redis-based pubsub functionality that require containerized services.